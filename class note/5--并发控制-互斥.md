# 自旋锁缺陷

性能问题 (0)

- 自旋 (共享变量) 会触发处理器间的缓存同步，延迟增加

------

性能问题 (1)

- 除了进入临界区的线程，其他处理器上的线程都在空转
- 争抢锁的处理器越多，利用率越低

------

性能问题 (2)

- 获得自旋锁的线程

  可能被操作系统切换出去

  - 操作系统不 “感知” 线程在做什么
  - (但为什么不能呢？)

- 实现 100% 的资源浪费

# 互斥分析

自旋锁 (线程直接共享 locked)

- 更快的 fast path
  - xchg 成功 → 立即进入临界区，开销很小
- 更慢的 slow path
  - xchg 失败 → 浪费 CPU 自旋等待

------

睡眠锁 (通过系统调用访问 locked)

- 更快的 slow path
  - 上锁失败线程不再占用 CPU
- 更慢的 fast path
  - 即便上锁成功也需要进出内核 (syscall)

# Futex: Fast Userspace muTexes

> 小孩子才做选择。我当然是全都要啦！

- Fast path: 一条原子指令，上锁成功立即返回
- Slow path: 上锁失败，执行系统调用睡眠
  - 性能优化的最常见技巧
    - 看 average (frequent) case 而不是 worst case

## 总结

本次课回答的问题

- **Q**: 如何在多处理器系统上实现互斥？

------

Take-away message

- 软件不够，硬件来凑 (自旋锁)
- 用户不够，内核来凑 (互斥锁)
  - 找到你依赖的假设，并大胆地打破它
- Fast/slow paths: 性能优化的重要途径